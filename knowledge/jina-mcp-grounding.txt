This file is a merged representation of the entire codebase, combined into a single document by Repomix. The content has been processed where empty lines have been removed.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.changeset/
  config.json
  README.md
src/
  index.ts
.gitignore
.prettierignore
.prettierrc
CHANGELOG.md
LICENSE
package.json
README.md
renovate.json
tsconfig.json

================================================================
Files
================================================================

================
File: .changeset/config.json
================
{
  "$schema": "https://unpkg.com/@changesets/config@3.0.5/schema.json",
  "changelog": "@changesets/cli/changelog",
  "commit": false,
  "fixed": [],
  "linked": [],
  "access": "public",
  "baseBranch": "main",
  "updateInternalDependencies": "patch",
  "ignore": []
}

================
File: .changeset/README.md
================
# Changesets

Hello and welcome! This folder has been automatically generated by `@changesets/cli`, a build tool that works
with multi-package repos, or single-package repos to help you version and publish your code. You can
find the full documentation for it [in our repository](https://github.com/changesets/changesets)

We have a quick list of common questions to get you started engaging with this project in
[our documentation](https://github.com/changesets/changesets/blob/main/docs/common-questions.md)

================
File: src/index.ts
================
#!/usr/bin/env node
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
	CallToolRequestSchema,
	ErrorCode,
	ListToolsRequestSchema,
	McpError,
} from '@modelcontextprotocol/sdk/types.js';
import { readFileSync } from 'fs';
import { dirname, join } from 'path';
import { fileURLToPath } from 'url';
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const pkg = JSON.parse(
	readFileSync(join(__dirname, '..', 'package.json'), 'utf8'),
);
const { name, version } = pkg;
// Get your Jina AI API key for free: https://jina.ai/?sui=apikey
const JINAAI_API_KEY = process.env.JINAAI_API_KEY;
if (!JINAAI_API_KEY) {
	throw new Error('JINAAI_API_KEY environment variable is required');
}
interface GroundingReference {
	url: string; // Source URL
	keyQuote: string; // Supporting quote from the source
	isSupportive: boolean; // Whether the reference supports or contradicts the statement
}
interface GroundingResponse {
	factuality: number; // Score between 0-1 indicating confidence
	result: boolean; // True if statement is verified as factual
	reason: string; // Explanation of the verification result
	references: GroundingReference[]; // Supporting/contradicting sources (up to 30)
	usage: {
		tokens: number; // Number of tokens processed
	};
}
interface GroundingOptions {
	statement: string; // Statement to verify
	references?: string[]; // Optional list of URLs to restrict search to
	no_cache?: boolean; // Whether to bypass cache for fresh results
}
const is_valid_grounding_args = (
	args: any,
): args is GroundingOptions =>
	typeof args === 'object' &&
	args !== null &&
	typeof args.statement === 'string' &&
	args.statement.trim() !== '' &&
	(args.references === undefined ||
		(Array.isArray(args.references) &&
			args.references.every((ref: string) => typeof ref === 'string'))) &&
	(args.no_cache === undefined || typeof args.no_cache === 'boolean');
class JinaGroundingServer {
	private server: Server;
	private base_url = 'https://g.jina.ai';
	constructor() {
		this.server = new Server(
			{
				name,
				version,
			},
			{
				capabilities: {
					tools: {},
				},
			},
		);
		this.setup_handlers();
		this.server.onerror = (error) =>
			console.error('[MCP Error]', error);
	}
	private setup_handlers() {
		this.server.setRequestHandler(
			ListToolsRequestSchema,
			async () => ({
				tools: [
					{
						name: 'ground_statement',
						description:
							'Ground a statement using real-time web search results to check factuality. ' +
							'When providing URLs via the references parameter, ensure they are publicly accessible ' +
							'and contain relevant information about the statement. If the URLs do not contain ' +
							'the necessary information, try removing the URL restrictions to search the entire web.',
						inputSchema: {
							type: 'object',
							properties: {
								statement: {
									type: 'string',
									description: 'Statement to be grounded',
								},
								references: {
									type: 'array',
									items: {
										type: 'string',
									},
									description:
										'Optional list of URLs to restrict search to. Only provide URLs that are ' +
										'publicly accessible and contain information relevant to the statement. ' +
										'If the URLs do not contain the necessary information, the grounding will fail. ' +
										'For best results, either provide URLs you are certain contain the information, ' +
										'or omit this parameter to search the entire web.',
								},
								no_cache: {
									type: 'boolean',
									description:
										'Whether to bypass cache for fresh results',
									default: false,
								},
							},
							required: ['statement'],
						},
					},
				],
			}),
		);
		this.server.setRequestHandler(
			CallToolRequestSchema,
			async (request) => {
				if (request.params.name !== 'ground_statement') {
					throw new McpError(
						ErrorCode.MethodNotFound,
						`Unknown tool: ${request.params.name}`,
					);
				}
				const args = request.params.arguments;
				if (!is_valid_grounding_args(args)) {
					throw new McpError(
						ErrorCode.InvalidParams,
						'Invalid parameters. Required: statement (string). Optional: references (string[]), no_cache (boolean)',
					);
				}
				try {
					const headers: Record<string, string> = {
						'Content-Type': 'application/json',
						Accept: 'application/json',
						Authorization: `Bearer ${JINAAI_API_KEY}`,
					};
					// Add optional headers
					if (args.references?.length) {
						headers['X-Site'] = args.references.join(',');
					}
					if (args.no_cache) {
						headers['X-No-Cache'] = 'true';
					}
					const response = await fetch(this.base_url, {
						method: 'POST',
						headers,
						body: JSON.stringify({
							statement: args.statement.trim(),
						}),
					});
					if (!response.ok) {
						const error_text = await response.text();
						let error_json;
						try {
							error_json = JSON.parse(error_text);
						} catch {
							throw new Error(
								`HTTP error! status: ${response.status}, message: ${error_text}`,
							);
						}
						// Handle specific error cases
						if (error_json.status === 42206) {
							throw new McpError(
								ErrorCode.InvalidParams,
								'The provided URLs did not contain relevant information for fact-checking. This can happen when:\n' +
								'1. The URLs are not publicly accessible\n' +
								'2. The URLs do not contain information about the specific statement\n' +
								'3. The information exists but is not in an easily searchable format\n\n' +
								'Suggestions:\n' +
								'- Remove the URL restrictions to search the entire web\n' +
								'- Provide different URLs that you are certain contain the information\n' +
								'- Verify the URLs are publicly accessible and contain relevant content',
							);
						}
						// Handle other API errors
						throw new Error(
							`API error! status: ${response.status}, message: ${error_json.readableMessage || error_json.message || error_text}`,
						);
					}
					const result = (await response.json()) as {
						code: number;
						status: number;
						data: GroundingResponse;
					};
					if (result.code !== 200) {
						throw new Error(`API error! status: ${result.status}`);
					}
					return {
						content: [
							{
								type: 'text',
								text: JSON.stringify(result.data, null, 2),
							},
						],
					};
				} catch (error) {
					const message =
						error instanceof Error ? error.message : String(error);
					throw new McpError(
						ErrorCode.InternalError,
						`Failed to ground statement: ${message}`,
					);
				}
			},
		);
	}
	async run() {
		const transport = new StdioServerTransport();
		await this.server.connect(transport);
		console.error('Jina Grounding MCP server running on stdio');
	}
}
const server = new JinaGroundingServer();
server.run().catch(console.error);

================
File: .gitignore
================
# Dependencies
node_modules/
.pnpm-store/

# Build output
dist/
build/

# Environment variables
.env
.env.local
.env.*.local

# IDE
.vscode/
.idea/
*.swp
*.swo

# Logs
*.log
npm-debug.log*
pnpm-debug.log*

# Testing
coverage/

# Database files
*.db
*.db-journal

# OS
.DS_Store
Thumbs.db

================
File: .prettierignore
================
# Package Managers
package-lock.json
pnpm-lock.yaml
yarn.lock

================
File: .prettierrc
================
{
	"useTabs": true,
	"singleQuote": true,
	"trailingComma": "all",
	"printWidth": 70,
	"proseWrap": "always"
}

================
File: CHANGELOG.md
================
# mcp-jinaai-reader

## 0.0.2

### Patch Changes

- add glama badge

## 0.0.1

### Patch Changes

- init

## 0.0.4

### Patch Changes

- fix: update README.md for mcp-jinaai-reader configuration

## 0.0.3

### Patch Changes

- add glama banner

## 0.0.2

### Patch Changes

- update for publish to npm

================
File: LICENSE
================
MIT License

Copyright (c) 2025 Scott Spence

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

================
File: package.json
================
{
	"name": "mcp-jinaai-grounding",
	"version": "0.0.2",
	"description": "MCP server for JinaAI grounding",
	"type": "module",
	"main": "dist/index.js",
	"types": "dist/index.d.ts",
	"bin": {
		"mcp-jinaai-grounding": "./dist/index.js"
	},
	"files": [
		"dist",
		"README.md",
		"LICENSE"
	],
	"scripts": {
		"build": "tsc && chmod +x dist/index.js",
		"start": "node dist/index.js",
		"dev": "npx @modelcontextprotocol/inspector dist/index.js",
		"changeset": "changeset",
		"version": "changeset version",
		"release": "pnpm run build && changeset publish"
	},
	"keywords": [
		"mcp",
		"model-context-protocol",
		"jinaai",
		"grounding",
		"web-content",
		"documentation",
		"content-extraction",
		"text-extraction",
		"llm",
		"ai",
		"web-scraping",
		"content-parser",
		"fact-checking",
		"content-verification",
		"real-time-content",
		"content-analysis",
		"content-relevance",
		"content-scoring"
	],
	"author": "Scott Spence",
	"license": "MIT",
	"repository": {
		"type": "git",
		"url": "https://github.com/spences10/mcp-jinaai-grounding.git"
	},
	"bugs": {
		"url": "https://github.com/spences10/mcp-jinaai-grounding/issues"
	},
	"homepage": "https://github.com/spences10/mcp-jinaai-grounding#readme",
	"dependencies": {
		"@modelcontextprotocol/sdk": "1.5.0"
	},
	"devDependencies": {
		"@changesets/cli": "^2.27.12",
		"@types/node": "^22.13.0",
		"typescript": "^5.7.3"
	}
}

================
File: README.md
================
# mcp-jinaai-grounding

A Model Context Protocol (MCP) server for integrating Jina.ai's
Grounding API with LLMs. This server provides efficient and
comprehensive web content grounding capabilities, optimized for
enhancing LLM responses with factual, real-time web content.

<a href="https://glama.ai/mcp/servers/urkuhet67l">
  <img width="380" height="200" src="https://glama.ai/mcp/servers/urkuhet67l/badge" />
</a>

## Features

- 🌐 Advanced web content grounding through Jina.ai Grounding API
- 🚀 Real-time content verification and fact-checking
- 📚 Comprehensive web content analysis
- 🔄 Clean format optimized for LLMs
- 🎯 Precise content relevance scoring
- 🏗️ Built on the Model Context Protocol

## Configuration

This server requires configuration through your MCP client. Here are
examples for different environments:

### Cline Configuration

Add this to your Cline MCP settings:

```json
{
	"mcpServers": {
		"jinaai-grounding": {
			"command": "node",
			"args": ["-y", "mcp-jinaai-grounding"],
			"env": {
				"JINAAI_API_KEY": "your-jinaai-api-key"
			}
		}
	}
}
```

### Claude Desktop with WSL Configuration

For WSL environments, add this to your Claude Desktop configuration:

```json
{
	"mcpServers": {
		"jinaai-grounding": {
			"command": "wsl.exe",
			"args": [
				"bash",
				"-c",
				"JINAAI_API_KEY=your-jinaai-api-key npx mcp-jinaai-grounding"
			]
		}
	}
}
```

### Environment Variables

The server requires the following environment variable:

- `JINAAI_API_KEY`: Your Jina.ai API key (required)

## API

The server implements MCP tools for grounding LLM responses with web
content:

### ground_content

Ground LLM responses with real-time web content using Jina.ai
Grounding.

Parameters:

- `query` (string, required): The text to ground with web content
- `no_cache` (boolean, optional): Bypass cache for fresh results.
  Defaults to false
- `format` (string, optional): Response format ("json" or "text").
  Defaults to "text"
- `token_budget` (number, optional): Maximum number of tokens for this
  request
- `browser_locale` (string, optional): Browser locale for rendering
  content
- `stream` (boolean, optional): Enable stream mode for large pages.
  Defaults to false
- `gather_links` (boolean, optional): Gather all links at the end of
  response. Defaults to false
- `gather_images` (boolean, optional): Gather all images at the end of
  response. Defaults to false
- `image_caption` (boolean, optional): Caption images in the content.
  Defaults to false
- `enable_iframe` (boolean, optional): Extract content from iframes.
  Defaults to false
- `enable_shadow_dom` (boolean, optional): Extract content from shadow
  DOM. Defaults to false
- `resolve_redirects` (boolean, optional): Follow redirect chains to
  final URL. Defaults to true

## Development

### Setup

1. Clone the repository
2. Install dependencies:

```bash
pnpm install
```

3. Build the project:

```bash
pnpm run build
```

4. Run in development mode:

```bash
pnpm run dev
```

### Publishing

1. Update version in package.json
2. Build the project:

```bash
pnpm run build
```

3. Publish to npm:

```bash
pnpm run release
```

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## License

MIT License - see the [LICENSE](LICENSE) file for details.

## Acknowledgments

- Built on the
  [Model Context Protocol](https://github.com/modelcontextprotocol)
- Powered by [Jina.ai Grounding API](https://jina.ai)

================
File: renovate.json
================
{
  "$schema": "https://docs.renovatebot.com/renovate-schema.json",
  "extends": [
    "config:recommended"
  ]
}

================
File: tsconfig.json
================
{
	"compilerOptions": {
		"target": "ES2020",
		"module": "ES2020",
		"moduleResolution": "node",
		"esModuleInterop": true,
		"strict": true,
		"outDir": "dist",
		"rootDir": "src",
		"skipLibCheck": true,
		"forceConsistentCasingInFileNames": true,
		"resolveJsonModule": true
	},
	"include": ["src/**/*"],
	"exclude": ["node_modules", "dist"]
}



================================================================
End of Codebase
================================================================
